using System.Reflection;
using System.Text;

namespace Typifier;

public static class Generator
{
    public static void Generate()
    {
        string namespaceName = "wshcmx";
        IEnumerable<System.Type> types = Assembly.Load(namespaceName)
            .GetTypes()
            .Where(x => !x.Name.EndsWith("Attribute") && x.IsClass && !x.Name.StartsWith("<"));

        StringBuilder sb = new();
        sb.AppendLine("// -------------------------------------------------------");
        sb.AppendLine("// <auto-generated>");
        sb.AppendLine($"//    This file is generated by {namespaceName}/net project. Do not edit manually.");
        sb.AppendLine($"//    Generated on: {DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss")}");
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("// -------------------------------------------------------");
        sb.AppendLine($"\ndeclare namespace {namespaceName} {{");
        sb.AppendLine($"  namespace Net {{");
        sb.AppendLine($"    type KeyValuePair<K, V> = {{ Key: K; Value: V }};");

        foreach (System.Type type in types)
        {
            sb.AppendLine($"\n    export abstract class {type.Name} {{");

            foreach (var method in type.GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly | BindingFlags.Static))
            {
                List<string> parameters = [];

                foreach (var parameter in method.GetParameters())
                {
                    parameters.Add($"{parameter.Name}: {MapType(parameter.ParameterType)}");
                }

                sb.AppendLine($"      {method.Name}({string.Join(", ", parameters)}): {MapType(method.ReturnType)};");
            }

            sb.AppendLine("    }");
        }

        sb.AppendLine("  }");
        sb.AppendLine("}");

        string buildPath = "./Externals";

        if (!Directory.Exists(buildPath))
        {
            Directory.CreateDirectory(buildPath);
        }

        File.WriteAllText(Path.Combine(buildPath, $"{namespaceName}.d.ts"), sb.ToString());
    }

    private static string MapType(Type type)
    {
        if (type == typeof(void)) return "void";
        if (type == typeof(string)) return "string";
        if (type == typeof(bool)) return "boolean";
        if (type == typeof(int)) return "number";
        if (type == typeof(object)) return "unknown";

        if (Nullable.GetUnderlyingType(type) != null)
        {
            return MapType(Nullable.GetUnderlyingType(type)) + " | null";
        }

        // Handle jagged arays
        if (type.IsArray)
        {
            var elementType = type.GetElementType();
            return MapType(elementType) + "[]";
        }

        if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(List<>))
        {
            return MapType(type.GetGenericArguments()[0]) + "[]";
        }

        if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(KeyValuePair<,>))
        {
            return $"{{ Key: {MapType(type.GetGenericArguments()[0])}; Value: {MapType(type.GetGenericArguments()[1])} }}";
        }

        return type.ToString();
    }
}